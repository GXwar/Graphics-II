<html>
  <head>
    <link href="./public/style/index.css" rel="stylesheet" type="text/css"/>
  </head>
<body>
  <h3 id="graphic">Graphics II - Lab 1</h3>
  <div>
    <canvas id="content" width="600" height="600"></canvas>
    <hr class="seperator" size=600>
    <div class="control-panel">
      <p class="title">1. Select a model:</p>
      <select class="choose_model">
        <option disabled selected value>Please select model</option>
      </select>
      <button class="render">Render</button>
      <p class="title">2. Camera parameter:</p>
      <div class="slidecontainer">
        <input id="h" type="range" min="0.1" max="10" value="1" step="0.1" class="slider">
        <p>h: <span id="h_V"></span></p>
      </div>
      <div class="slidecontainer">
        <input id="d" type="range" min="0.1" max="10" value="1" step="0.1" class="slider">
        <p>d: <span id="d_V"></span></p>
      </div>
      <div class="slidecontainer">
        <input id="f" type="range" min="10" max="500" value="100" class="slider">
        <p>f: <span id="f_V"></span></p>
      </div>
      <div class="instruction">
        <p class="title">3. Instruction</p>
        <ul>
          <li>Using mouse wheel to scale up or down the model</li>
          <li>Using w, a, s, d to move object</li>
        </ul>
      </div>
    </div>
  </dvi>
</body>
<script type="module">
  import { render } from './src/utils/render.js';
  import camera from './src/configs/camera.js';
  import model from './src/configs/model.js';
  import { bindSlider, loadMenu, reactToOperation } from './src/utils/dom.js';
  import { vectorSubtract, vectorUnit, vector3dCrossProduct, vectorCollapse, vectorExtend, vectorScale } from './src/operate/vector.js';
  import { matrixMultiply, matrixMultiplyVector } from './src/operate/matrix.js';
  import {
    model2World,
    world2Camera,
    perspectiveTrans,
    backFaceCulling
  } from './src/operate/transform.js';

  /******************** Initialize ********************/
  reactToOperation(draw);
  // Get canvas
  const canvas = document.querySelector('#content');
  const [height, width] = [canvas.height, canvas.width];
  const ctx = canvas.getContext('2d');
  ctx.fillRect(0, 0, width, height);
  ctx.strokeStyle = 'green';
  const ticks = 16;
  // Bind slide with data
  ['h', 'd', 'f'].forEach(item => bindSlider(item, draw));
  // Load all model options to menu
  const choose_model = document.querySelector('select.choose_model');
  loadMenu(choose_model);
  // Caluate N, U, V
  const cameraInit = () => {
    camera.N = vectorUnit(vectorSubtract(camera.pRef, camera.C));
    camera.U = vectorUnit(vector3dCrossProduct(camera.N, camera.UP));
    camera.V = vector3dCrossProduct(camera.U, camera.N);
  };
  

  /******************** Render Model ********************/
  const renderBtn = document.querySelector('.render');
  renderBtn.addEventListener('click', () => {
    const modelIndex = choose_model.selectedIndex;
    if (modelIndex === 0) {
      alert('Please select a model to render');
    }
    const modelName = choose_model.options[modelIndex].value;
    render(`./public/model/${modelName}.d.txt`, draw);
  });

  // Calculate model
  const pureModel = model => {
    const combo = matrixMultiply(perspectiveTrans(), world2Camera());
    return model.points.map(point => {
      let t = matrixMultiplyVector(combo, vectorExtend(point));
      return vectorCollapse(t);
    });
  };

  let factor;
  let [xMax, yMax] = [-1, -1];
  const helper = (calcPoints, len) => {
    if (!factor) {
      calcPoints.forEach(point => {
        xMax = Math.max(xMax, Math.abs(point[0]));
        yMax = Math.max(yMax, Math.abs(point[1]));
      });
      factor = Math.floor(len / Math.max(xMax, yMax));
    }
    return calcPoints.map(point => [
      point[0] * factor / 3 + Math.max(xMax, yMax) * factor / 2,
      -point[1] * factor / 3 + Math.max(xMax, yMax) * factor / 2
    ]);
  };

  // Render model
  function draw() {
    let calcPoints = pureModel(model);
    backFaceCulling(calcPoints);
    calcPoints = helper(pureModel(model), Math.min(width, height));
    ctx.clearRect(0, 0, width, height);
    ctx.fillRect(0, 0, width, height);
    model.backFaceCullingFaces.forEach((face, index) => {
      let n = face.length;
      ctx.beginPath();
      ctx.moveTo(calcPoints[face[0]][0], calcPoints[face[0]][1]);
      for (let i = 1; i < n; i++) {
        ctx.lineTo(calcPoints[face[i]][0], calcPoints[face[i]][1]);
      }
      ctx.closePath();
      ctx.stroke();
    });
  };
</script>

</html>